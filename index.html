<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Foundation Models for the Brain</title>
  <meta name="description" content="An invite-only research convening on brain foundation models. March 26, 2026 in New York City.">

  <!-- Open Graph -->
  <meta property="og:title" content="Foundation Models for the Brain">
  <meta property="og:description" content="An invite-only research convening on brain foundation models. March 26, 2026 in New York City.">
  <meta property="og:type" content="website">

  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="assets/favicon.svg">

  <style>
    /* ========== DESIGN TOKENS ========== */
    :root {
      /* Colors */
      --ink: #1F1F1F;
      --muted: #6B6B6B;
      --quiet: #8A8A8A;
      --rule: #E3E3E3;
      --bg: #F7F6F4;
      --accent: #79BFD0;
      --accent-light: #A8D5E2;

      /* Fonts */
      --font-display: Georgia, "Times New Roman", serif;
      --font-sans: "Helvetica Neue", Helvetica, Arial, sans-serif;

      /* Type scale */
      --h1: clamp(48px, 5.5vw, 72px);
      --h2: 26px;
      --h3: 18px;
      --kicker: 12px;
      --body: 17px;
      --small: 15px;

      /* Line heights */
      --lh-tight: 1.08;
      --lh-head: 1.2;
      --lh-body: 1.65;

      /* Letter spacing */
      --track-tight: -0.01em;
      --track-caps: 0.18em;

      /* Layout */
      --left-margin: 10vw;
    }

    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: var(--font-sans);
      font-size: var(--body);
      line-height: var(--lh-body);
      color: var(--ink);
      background-color: var(--bg);
      -webkit-font-smoothing: antialiased;
    }

    /* ========== LAYOUT ========== */
    .page-wrap {
      padding-left: var(--left-margin);
      padding-right: 5vw;
    }

    .content-width {
      max-width: 1100px;
    }

    /* ========== NAVIGATION ========== */
    .nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 24px 0;
      border-bottom: 1px solid var(--rule);
      margin-bottom: 60px;
    }

    .nav-brand {
      font-size: var(--kicker);
      font-weight: 500;
      letter-spacing: var(--track-caps);
      text-transform: uppercase;
      color: var(--muted);
      text-decoration: none;
      transition: color 0.2s ease;
    }

    .nav-brand:hover {
      color: var(--accent);
    }

    .nav-links {
      font-size: var(--kicker);
      font-weight: 500;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--quiet);
    }

    .nav-links a {
      color: inherit;
      text-decoration: none;
      transition: color 0.2s ease;
    }

    .nav-links a:hover {
      color: var(--accent);
    }

    /* ========== HERO ========== */
    .hero {
      position: relative;
      min-height: 420px;
      padding-bottom: 60px;
      overflow: hidden;
    }

    .hero-content {
      position: relative;
      z-index: 2;
      max-width: 600px;
      padding-top: 20px;
    }

    /* Hero Title - Serif display, the ONE editorial element */
    .hero-title {
      font-family: var(--font-display);
      font-size: var(--h1);
      font-weight: 400;
      line-height: var(--lh-tight);
      letter-spacing: var(--track-tight);
      color: var(--ink);
      margin-bottom: 20px;
    }

    /* Hero text: unified system for subtitle, lede, and meta */
    .hero-subtitle,
    .hero-lede {
      font-family: var(--font-sans);
      font-size: 18px;
      font-weight: 400;
      font-style: normal;
      line-height: 1.5;
      color: var(--muted);
      max-width: 540px;
      margin: 0 0 14px 0;
    }

    .hero-meta {
      font-family: var(--font-sans);
      font-size: 18px;
      font-weight: 400;
      line-height: 1.5;
      color: #4f4f4f;
      letter-spacing: 0.02em;
      margin: 0;
    }

    /* ========== HERO ANIMATION ========== */
    .hero-visual {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
    }

    .hero-visual canvas {
      width: 100%;
      height: 100%;
    }

    /* Reduced motion: show static final state */
    @media (prefers-reduced-motion: reduce) {
      .hero-visual canvas {
        animation: none;
      }
    }

    /* ========== SECTION DIVIDER ========== */
    .section-divider {
      position: relative;
      height: 1px;
      background: var(--rule);
      margin: 60px 0;
    }

    .section-divider::after {
      content: '';
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 8px;
      height: 8px;
      background: var(--accent);
      border-radius: 50%;
    }

    .section-divider.dot-20::after { left: 20%; }
    .section-divider.dot-35::after { left: 35%; }
    .section-divider.dot-50::after { left: 50%; }
    .section-divider.dot-65::after { left: 65%; }
    .section-divider.dot-80::after { left: 80%; }

    /* ========== SECTIONS ========== */
    section {
      padding-bottom: 20px;
    }

    /* Section titles - Real headings, sentence case */
    .section-title {
      font-family: var(--font-sans);
      font-size: var(--h2);
      font-weight: 600;
      color: var(--ink);
      margin-bottom: 28px;
      line-height: var(--lh-head);
    }

    /* ========== EPIGRAPH ========== */
    .epigraph {
      border-left: 3px solid var(--accent);
      padding-left: 20px;
      margin: 0 0 40px;
      max-width: 580px;
    }

    .epigraph blockquote {
      font-family: var(--font-sans);
      font-size: 18px;
      font-weight: 400;
      font-style: normal;
      line-height: 1.5;
      color: var(--muted);
      margin: 0 0 10px;
    }

    .epigraph cite {
      display: block;
      font-family: var(--font-sans);
      font-size: 14px;
      font-style: normal;
      color: var(--quiet);
    }

    /* ========== PURPOSE CONTENT ========== */
    .purpose-content {
      max-width: 640px;
    }

    .purpose-content p {
      font-size: var(--body);
      margin-bottom: 24px;
      line-height: var(--lh-body);
      color: var(--muted);
    }

    /* ========== QUESTIONS ========== */
    .questions {
      max-width: 640px;
    }

    .questions-intro {
      font-size: var(--small);
      font-weight: 500;
      color: var(--muted);
      margin-bottom: 24px;
    }

    .questions-list {
      list-style: none;
    }

    .questions-list li {
      position: relative;
      padding-left: 20px;
      margin-bottom: 20px;
    }

    .questions-list li::before {
      content: '';
      position: absolute;
      left: 0;
      top: 8px;
      width: 6px;
      height: 6px;
      background: var(--accent);
      border-radius: 50%;
    }

    .questions-list .q {
      font-family: var(--font-sans);
      font-size: var(--body);
      font-weight: 500;
      color: var(--ink);
      line-height: 1.4;
      margin-bottom: 4px;
    }

    .questions-list .context {
      font-size: var(--small);
      color: var(--muted);
      line-height: 1.55;
    }

    /* ========== PROGRAM ========== */
    .program-grid {
      max-width: 640px;
    }

    .program-item {
      display: grid;
      grid-template-columns: 55px 1fr;
      gap: 20px;
      padding: 16px 0;
      border-bottom: 1px solid var(--rule);
    }

    .program-item:first-child {
      padding-top: 0;
    }

    .program-item:last-child {
      border-bottom: none;
    }

    .program-time {
      font-size: 14px;
      font-weight: 500;
      color: var(--quiet);
      font-variant-numeric: tabular-nums;
    }

    .program-title {
      font-size: var(--body);
      font-weight: 600;
      color: var(--ink);
      margin-bottom: 4px;
    }

    .program-desc {
      font-size: var(--small);
      color: var(--muted);
      line-height: 1.5;
    }

    /* ========== HOSTS ========== */
    .hosts-list {
      max-width: 640px;
      margin-bottom: 24px;
    }

    .hosts-list p {
      margin-bottom: 10px;
      font-size: var(--body);
    }

    .hosts-list a {
      color: var(--ink);
      text-decoration: none;
      font-weight: 600;
      transition: color 0.2s ease;
    }

    .hosts-list a:hover {
      color: var(--accent);
    }

    .hosts-list .role {
      color: var(--muted);
      font-weight: 400;
    }

    .hosts-meta {
      font-size: var(--small);
      color: var(--muted);
      margin-bottom: 18px;
      max-width: 640px;
    }

    .hosts-meta a {
      color: var(--ink);
      text-decoration: none;
      transition: color 0.2s ease;
    }

    .hosts-meta a:hover {
      color: var(--accent);
    }

    .organizers {
      font-size: var(--small);
      color: var(--muted);
    }

    .organizers a {
      color: var(--ink);
      text-decoration: none;
      transition: color 0.2s ease;
    }

    .organizers a:hover {
      color: var(--accent);
    }

    /* ========== CONTACT ========== */
    .contact-form {
      display: flex;
      flex-direction: column;
      gap: 24px;
      max-width: 400px;
      margin-bottom: 32px;
    }

    .form-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .form-group label {
      font-size: 14px;
      font-weight: 500;
      color: var(--quiet);
    }

    .form-group .optional {
      font-weight: 400;
    }

    .form-group input,
    .form-group textarea {
      font-family: var(--font-sans);
      font-size: 16px;
      padding: 12px 0;
      border: none;
      border-bottom: 1px solid var(--rule);
      background: transparent;
      color: var(--ink);
      transition: border-color 0.2s ease;
    }

    .form-group input:focus,
    .form-group textarea:focus {
      outline: none;
      border-bottom-color: var(--accent);
    }

    .form-group textarea {
      resize: vertical;
      min-height: 80px;
    }

    .submit-btn {
      align-self: flex-start;
      font-family: var(--font-sans);
      font-size: 14px;
      font-weight: 600;
      color: var(--ink);
      background: transparent;
      border: none;
      border-bottom: 1px solid var(--ink);
      padding: 0 0 4px 0;
      cursor: pointer;
      transition: color 0.2s ease, border-color 0.2s ease;
    }

    .submit-btn:hover {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }

    .contact-email {
      font-size: var(--small);
      color: var(--muted);
    }

    .contact-email a {
      color: var(--ink);
      text-decoration: none;
      transition: color 0.2s ease;
    }

    .contact-email a:hover {
      color: var(--accent);
    }

    /* ========== FOOTER ========== */
    footer {
      padding: 48px 0;
      border-top: 1px solid var(--rule);
      margin-top: 40px;
      text-align: left;
    }

    .footer-dot {
      width: 8px;
      height: 8px;
      background: var(--accent);
      border-radius: 50%;
      margin-bottom: 20px;
    }

    footer p {
      font-size: 13px;
      color: var(--quiet);
      margin-bottom: 6px;
    }

    footer .host-credit {
      font-size: 12px;
      color: var(--quiet);
    }

    /* ========== RESPONSIVE ========== */
    @media (max-width: 1024px) {
      :root {
        --left-margin: 5vw;
      }

      .hero {
        min-height: 380px;
      }
    }

    @media (max-width: 768px) {
      :root {
        --left-margin: 24px;
        --h1: 40px;
        --h2: 22px;
      }

      .page-wrap {
        padding-right: 24px;
      }

      .nav {
        flex-direction: column;
        gap: 16px;
        align-items: flex-start;
        margin-bottom: 40px;
      }

      .hero {
        min-height: auto;
        padding-bottom: 48px;
      }

      .hero-subtitle,
      .hero-lede,
      .hero-meta {
        font-size: 16px;
      }

      .hero-visual {
        opacity: 0.4;
      }

      .section-divider {
        margin: 48px 0;
      }

      .program-item {
        grid-template-columns: 50px 1fr;
        gap: 16px;
      }
    }

    @media (max-width: 480px) {
      :root {
        --h1: 34px;
        --h2: 20px;
      }

      .hero-subtitle,
      .hero-lede,
      .hero-meta {
        font-size: 15px;
      }

      .hero-visual {
        opacity: 0.3;
      }

      .program-item {
        grid-template-columns: 1fr;
        gap: 6px;
      }

      .program-time {
        font-size: 13px;
      }
    }
  </style>
</head>
<body>

  <div class="page-wrap">
    <div class="content-width">

      <!-- Navigation -->
      <nav class="nav">
        <a href="#" class="nav-brand">e184 × NeuroNYC</a>
        <div class="nav-links">
          <a href="#purpose">Purpose</a> · <a href="#program">Program</a> · <a href="#hosts">Hosts</a> · <a href="#contact">Contact</a>
        </div>
      </nav>

      <!-- Hero -->
      <section class="hero">
        <div class="hero-content">
          <h1 class="hero-title">Foundation Models<br>for the Brain</h1>
          <p class="hero-subtitle">Laying the groundwork for the next stage in neurotech and AI</p>
          <p class="hero-lede">An invite-only evening for researchers working on brain foundation models—across hardware, data, and real-world systems.</p>
          <p class="hero-meta">March 26, 2026 · 5–9 PM · Brown Rudnick · New York City</p>
        </div>

        <!-- Animated Background: Signal to Structure -->
        <div class="hero-visual" id="heroVisual">
          <canvas id="heroCanvas"></canvas>
        </div>
      </section>

      <!-- Divider -->
      <div class="section-divider dot-65"></div>

      <!-- Purpose Section -->
      <section id="purpose">
        <!-- Epigraph -->
        <div class="epigraph">
          <blockquote>
            "The most fruitful areas for the growth of the sciences were those which had been neglected as a no-man's land between the various established fields."
          </blockquote>
          <cite>— Norbert Wiener, 1948</cite>
        </div>

        <h2 class="section-title">Purpose of the event</h2>

        <div class="purpose-content">
          <p>Brain foundation models are advancing quickly, but the field is still working through basic constraints: what kinds of data are realistically available, what today's sensors can and can't capture, and what "progress" should mean in practice. Across the field, teams are pursuing different strategies—pushing existing sensors further, leaning on multimodal inputs, drawing on non-human data, building models around specific settings, or prioritizing near-term deployment.</p>

          <p>This invite-only evening brings together an interdisciplinary group of researchers and practitioners to share what's working, what isn't, and what "working" should even mean—given constraints in neural data, sensing, and deployment. The format: two panels, short provocations, and substantial time for discussion.</p>
        </div>

        <div class="questions">
          <p class="questions-intro">Questions we'll explore:</p>
          <ul class="questions-list">
            <li>
              <p class="q">Where is the bottleneck right now?</p>
              <p class="context">Is progress primarily constrained by sensors, data access, or modeling assumptions?</p>
            </li>
            <li>
              <p class="q">Which workarounds seem most promising—and why?</p>
              <p class="context">What strategies meaningfully move the needle under current constraints?</p>
            </li>
            <li>
              <p class="q">What counts as "enough" data (and of what kind)?</p>
              <p class="context">When does scale help, and when are there hard limits?</p>
            </li>
            <li>
              <p class="q">What does "working" mean in this space?</p>
              <p class="context">Which outcomes or applications feel real today, and which remain aspirational?</p>
            </li>
            <li>
              <p class="q">How do research and real-world systems inform one another?</p>
              <p class="context">What can we learn from early deployments, and what gets lost in translation?</p>
            </li>
          </ul>
        </div>
      </section>

      <!-- Divider -->
      <div class="section-divider dot-35"></div>

      <!-- Program Section -->
      <section id="program">
        <h2 class="section-title">Program</h2>

        <div class="program-grid">
          <div class="program-item">
            <span class="program-time">5:00</span>
            <div>
              <p class="program-title">Welcome and drinks</p>
            </div>
          </div>
          <div class="program-item">
            <span class="program-time">5:30</span>
            <div>
              <p class="program-title">Panel 1 — Building a high-quality brain foundation model</p>
              <p class="program-desc">Constraints, workaround strategies, and what the field still needs to figure out.</p>
            </div>
          </div>
          <div class="program-item">
            <span class="program-time">6:30</span>
            <div>
              <p class="program-title">Panel 2 — From research to deployment</p>
              <p class="program-desc">Validation, integration, and near-term value across clinical, invasive, and consumer paths.</p>
            </div>
          </div>
          <div class="program-item">
            <span class="program-time">7:30</span>
            <div>
              <p class="program-title">Keynote</p>
            </div>
          </div>
          <div class="program-item">
            <span class="program-time">8:00</span>
            <div>
              <p class="program-title">Reception and informal discussion</p>
            </div>
          </div>
        </div>
      </section>

      <!-- Divider -->
      <div class="section-divider dot-50"></div>

      <!-- Hosts Section -->
      <section id="hosts">
        <h2 class="section-title">Hosts & Venue</h2>

        <div class="hosts-list">
          <p><a href="https://e184.org" target="_blank" rel="noopener">e184</a> <span class="role">— Co-host</span></p>
          <p><a href="https://neuro-nyc.org" target="_blank" rel="noopener">NeuroNYC</a> <span class="role">— Co-host</span></p>
          <p><a href="https://www.brownrudnick.com" target="_blank" rel="noopener">Brown Rudnick</a> <span class="role">— Venue</span></p>
        </div>

        <p class="organizers">
          Organized by
          <a href="https://www.linkedin.com/in/margot-hanley-phd-5183aa20/" target="_blank" rel="noopener">Margot Hanley</a> (NeuroNYC)
          and
          <a href="https://www.linkedin.com/in/peter-zhegin-526a993/" target="_blank" rel="noopener">Peter Zhegin</a> (e184)
        </p>
      </section>

      <!-- Divider -->
      <div class="section-divider dot-20"></div>

      <!-- Contact Section -->
      <section id="contact">
        <h2 class="section-title">Request an invite</h2>

        <form class="contact-form" action="https://formspree.io/f/placeholder" method="POST">
          <div class="form-group">
            <label for="name">Name</label>
            <input type="text" id="name" name="name" required>
          </div>
          <div class="form-group">
            <label for="email">Email</label>
            <input type="email" id="email" name="email" required>
          </div>
          <div class="form-group">
            <label for="affiliation">Affiliation</label>
            <input type="text" id="affiliation" name="affiliation" required>
          </div>
          <div class="form-group">
            <label for="note">Note <span class="optional">(optional)</span></label>
            <textarea id="note" name="note" placeholder="Brief context on your work or interest"></textarea>
          </div>
          <button type="submit" class="submit-btn">Submit request →</button>
        </form>

        <p class="contact-email">For other questions, reach out to <a href="mailto:margothanley@gmail.com">margothanley@gmail.com</a></p>
      </section>

      <!-- Footer -->
      <footer>
        <div class="footer-dot"></div>
        <p>Foundation Models for the Brain · March 26, 2026 · New York City</p>
        <p class="host-credit">Hosted by e184 × NeuroNYC</p>
      </footer>

    </div>
  </div>

  <!-- Hero Animation: Signal → Structure (Right side only, fluid motion) -->
  <script>
    (function() {
      'use strict';

      // ============ CONFIGURATION ============
      const CONFIG = {
        dotCount: 60,
        dotMinRadius: 2.5,
        dotMaxRadius: 5,

        // Colors
        colors: {
          primary: 'rgba(121, 191, 208, 0.8)',
          secondary: 'rgba(142, 200, 215, 0.7)',
          tertiary: 'rgba(168, 213, 226, 0.6)',
          line: 'rgba(121, 191, 208, 0.2)'
        },

        // Network
        maxEdgesPerNode: 2,
        edgeDistance: 70,
        lineWidth: 1,

        // Timing (slower, more fluid)
        timing: {
          scatter: 3,
          swirl: 6,
          structure: 5,
          rest: 4,
          dissolve: 4,
          total: 22
        },

        // Physics (much smoother)
        smoothing: 0.03,  // Lower = smoother/slower
        dampening: 0.92
      };

      const canvas = document.getElementById('heroCanvas');
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      const container = document.getElementById('heroVisual');
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      let width, height, dpr;
      let dots = [];
      let edges = [];
      let animationTime = 0;
      let lastTimestamp = 0;
      let clusterCenters = [];

      // Safe zone: don't draw here (where text is)
      let safeZoneWidth = 0;

      function resize() {
        dpr = window.devicePixelRatio || 1;
        width = container.offsetWidth;
        height = container.offsetHeight;

        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        ctx.scale(dpr, dpr);

        // Safe zone = left 55% of canvas (where hero text is)
        safeZoneWidth = width * 0.55;

        // Animation zone = right 45% of canvas
        const animZoneStart = safeZoneWidth;
        const animZoneWidth = width - safeZoneWidth;
        const vertPadding = height * 0.1;

        // Cluster centers in animation zone only
        clusterCenters = [
          { x: animZoneStart + animZoneWidth * 0.25, y: vertPadding + height * 0.2 },
          { x: animZoneStart + animZoneWidth * 0.55, y: vertPadding + height * 0.35 },
          { x: animZoneStart + animZoneWidth * 0.35, y: vertPadding + height * 0.55 },
          { x: animZoneStart + animZoneWidth * 0.65, y: vertPadding + height * 0.7 }
        ];
      }

      function initDots() {
        dots = [];
        const colorTypes = ['primary', 'secondary', 'tertiary'];

        for (let i = 0; i < CONFIG.dotCount; i++) {
          const clusterIndex = Math.floor(Math.random() * clusterCenters.length);
          const cluster = clusterCenters[clusterIndex];

          // Scatter position: RIGHT side only (in animation zone)
          const scatterX = safeZoneWidth + Math.random() * (width - safeZoneWidth - 20);
          const scatterY = Math.random() * height * 0.8 + height * 0.1;

          // Target position: near cluster
          const targetX = cluster.x + (Math.random() - 0.5) * 50;
          const targetY = cluster.y + (Math.random() - 0.5) * 40;

          const colorType = colorTypes[Math.floor(Math.random() * colorTypes.length)];

          dots.push({
            x: scatterX,
            y: scatterY,
            vx: 0,
            vy: 0,
            scatterX,
            scatterY,
            targetX,
            targetY,
            radius: CONFIG.dotMinRadius + Math.random() * (CONFIG.dotMaxRadius - CONFIG.dotMinRadius),
            color: CONFIG.colors[colorType],
            cluster: clusterIndex,
            phase: Math.random() * Math.PI * 2,
            speed: 0.15 + Math.random() * 0.15  // Slower base speed
          });
        }
      }

      function calculateEdges() {
        edges = [];
        for (let i = 0; i < dots.length; i++) {
          const dot = dots[i];
          const distances = [];

          for (let j = 0; j < dots.length; j++) {
            if (i === j) continue;
            const other = dots[j];
            const dx = dot.targetX - other.targetX;
            const dy = dot.targetY - other.targetY;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < CONFIG.edgeDistance) {
              distances.push({ index: j, dist });
            }
          }

          distances.sort((a, b) => a.dist - b.dist);
          const edgeCount = Math.min(CONFIG.maxEdgesPerNode, distances.length);

          for (let k = 0; k < edgeCount; k++) {
            const j = distances[k].index;
            if (i < j) {
              edges.push({ from: i, to: j });
            }
          }
        }
      }

      // Smooth easing
      function easeInOutSine(t) {
        return -(Math.cos(Math.PI * t) - 1) / 2;
      }

      function getPhase(time) {
        const t = CONFIG.timing;
        const loopTime = time % t.total;

        if (loopTime < t.scatter) {
          return { phase: 'scatter', progress: loopTime / t.scatter };
        } else if (loopTime < t.scatter + t.swirl) {
          return { phase: 'swirl', progress: (loopTime - t.scatter) / t.swirl };
        } else if (loopTime < t.scatter + t.swirl + t.structure) {
          return { phase: 'structure', progress: (loopTime - t.scatter - t.swirl) / t.structure };
        } else if (loopTime < t.scatter + t.swirl + t.structure + t.rest) {
          return { phase: 'rest', progress: 1 };
        } else {
          return { phase: 'dissolve', progress: (loopTime - t.scatter - t.swirl - t.structure - t.rest) / t.dissolve };
        }
      }

      function updateDots(phaseInfo) {
        const { phase, progress } = phaseInfo;

        dots.forEach(dot => {
          let goalX, goalY;

          // Very gentle ambient drift (always applied)
          const drift = Math.sin(animationTime * 0.1 + dot.phase) * 3;
          const driftY = Math.cos(animationTime * 0.08 + dot.phase) * 3;

          if (phase === 'scatter') {
            // Gentle float in scattered positions
            goalX = dot.scatterX + Math.sin(animationTime * dot.speed + dot.phase) * 8 + drift;
            goalY = dot.scatterY + Math.cos(animationTime * dot.speed * 0.8 + dot.phase) * 8 + driftY;

          } else if (phase === 'swirl') {
            // Smoothly interpolate toward target with gentle spiral
            const t = easeInOutSine(progress);
            const spiralAngle = animationTime * 0.2 + dot.phase;
            const spiralRadius = 20 * (1 - t);

            goalX = dot.scatterX + (dot.targetX - dot.scatterX) * t + Math.cos(spiralAngle) * spiralRadius;
            goalY = dot.scatterY + (dot.targetY - dot.scatterY) * t + Math.sin(spiralAngle) * spiralRadius;

          } else if (phase === 'structure') {
            // Settle with decreasing movement
            const t = easeInOutSine(progress);
            const settle = 1 - t * 0.8;
            goalX = dot.targetX + drift * settle;
            goalY = dot.targetY + driftY * settle;

          } else if (phase === 'rest') {
            // Very subtle breathing
            goalX = dot.targetX + Math.sin(animationTime * 0.15 + dot.phase) * 2;
            goalY = dot.targetY + Math.cos(animationTime * 0.12 + dot.phase) * 2;

          } else if (phase === 'dissolve') {
            // Gently drift back to scattered
            const t = easeInOutSine(progress);
            goalX = dot.targetX + (dot.scatterX - dot.targetX) * t + drift * t;
            goalY = dot.targetY + (dot.scatterY - dot.targetY) * t + driftY * t;
          }

          // Very smooth interpolation (key to fluid motion)
          dot.x += (goalX - dot.x) * CONFIG.smoothing;
          dot.y += (goalY - dot.y) * CONFIG.smoothing;
        });
      }

      function draw(phaseInfo) {
        const { phase, progress } = phaseInfo;

        ctx.clearRect(0, 0, width, height);

        // Edge opacity
        let edgeOpacity = 0;
        if (phase === 'swirl' && progress > 0.6) {
          edgeOpacity = (progress - 0.6) * 2.5 * 0.25;
        } else if (phase === 'structure') {
          edgeOpacity = 0.25 + easeInOutSine(progress) * 0.1;
        } else if (phase === 'rest') {
          edgeOpacity = 0.35;
        } else if (phase === 'dissolve') {
          edgeOpacity = 0.35 * (1 - easeInOutSine(progress));
        }

        // Draw edges
        if (edgeOpacity > 0.01) {
          ctx.strokeStyle = `rgba(121, 191, 208, ${edgeOpacity})`;
          ctx.lineWidth = CONFIG.lineWidth;
          ctx.lineCap = 'round';
          ctx.beginPath();

          edges.forEach(edge => {
            const from = dots[edge.from];
            const to = dots[edge.to];
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
          });

          ctx.stroke();
        }

        // Draw dots
        dots.forEach(dot => {
          ctx.beginPath();
          ctx.arc(dot.x, dot.y, dot.radius, 0, Math.PI * 2);
          ctx.fillStyle = dot.color;
          ctx.fill();
        });
      }

      function animate(timestamp) {
        if (!lastTimestamp) lastTimestamp = timestamp;
        const deltaTime = Math.min((timestamp - lastTimestamp) / 1000, 0.1);
        lastTimestamp = timestamp;

        animationTime += deltaTime;

        const phaseInfo = getPhase(animationTime);
        updateDots(phaseInfo);
        draw(phaseInfo);

        requestAnimationFrame(animate);
      }

      function drawStaticFinalState() {
        ctx.clearRect(0, 0, width, height);

        dots.forEach(dot => {
          dot.x = dot.targetX;
          dot.y = dot.targetY;
        });

        ctx.strokeStyle = CONFIG.colors.line;
        ctx.lineWidth = CONFIG.lineWidth;
        ctx.lineCap = 'round';
        ctx.beginPath();

        edges.forEach(edge => {
          ctx.moveTo(dots[edge.from].x, dots[edge.from].y);
          ctx.lineTo(dots[edge.to].x, dots[edge.to].y);
        });
        ctx.stroke();

        dots.forEach(dot => {
          ctx.beginPath();
          ctx.arc(dot.x, dot.y, dot.radius, 0, Math.PI * 2);
          ctx.fillStyle = dot.color;
          ctx.fill();
        });
      }

      function init() {
        resize();
        initDots();
        calculateEdges();

        if (prefersReducedMotion) {
          drawStaticFinalState();
        } else {
          requestAnimationFrame(animate);
        }
      }

      let resizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          resize();
          initDots();
          calculateEdges();
          if (prefersReducedMotion) drawStaticFinalState();
        }, 150);
      });

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>

</body>
</html>
