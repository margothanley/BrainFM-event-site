<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Foundation Models for the Brain</title>
  <meta name="description" content="An invite-only research convening on brain foundation models. March 26, 2026 in New York City.">

  <!-- Open Graph -->
  <meta property="og:title" content="Foundation Models for the Brain">
  <meta property="og:description" content="An invite-only research convening on brain foundation models. March 26, 2026 in New York City.">
  <meta property="og:type" content="website">

  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="assets/favicon.svg">

  <style>
    /* ========== DESIGN TOKENS ========== */
    :root {
      /* Colors */
      --ink: #1F1F1F;
      --muted: #6B6B6B;
      --quiet: #8A8A8A;
      --rule: #E3E3E3;
      --bg: #F7F6F4;
      --accent: #79BFD0;
      --accent-light: #A8D5E2;

      /* Fonts */
      --font-display: Georgia, "Times New Roman", serif;
      --font-sans: "Helvetica Neue", Helvetica, Arial, sans-serif;

      /* Type scale */
      --h1: clamp(48px, 5.5vw, 72px);
      --h2: 26px;
      --h3: 18px;
      --kicker: 12px;
      --body: 17px;
      --small: 15px;

      /* Line heights */
      --lh-tight: 1.08;
      --lh-head: 1.2;
      --lh-body: 1.65;

      /* Letter spacing */
      --track-tight: -0.01em;
      --track-caps: 0.18em;

      /* Layout */
      --left-margin: 10vw;
    }

    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: var(--font-sans);
      font-size: var(--body);
      line-height: var(--lh-body);
      color: var(--ink);
      background-color: var(--bg);
      -webkit-font-smoothing: antialiased;
    }

    /* ========== LAYOUT ========== */
    .page-wrap {
      padding-left: var(--left-margin);
      padding-right: 5vw;
    }

    .content-width {
      max-width: 1100px;
    }

    /* ========== NAVIGATION ========== */
    .nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 24px 0;
      border-bottom: 1px solid var(--rule);
      margin-bottom: 60px;
    }

    .nav-brand {
      font-size: var(--kicker);
      font-weight: 500;
      letter-spacing: var(--track-caps);
      text-transform: uppercase;
      color: var(--muted);
      text-decoration: none;
      transition: color 0.2s ease;
    }

    .nav-brand:hover {
      color: var(--accent);
    }

    .nav-links {
      font-size: var(--kicker);
      font-weight: 500;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--quiet);
    }

    .nav-links a {
      color: inherit;
      text-decoration: none;
      transition: color 0.2s ease;
    }

    .nav-links a:hover {
      color: var(--accent);
    }

    /* ========== HERO ========== */
    .hero {
      position: relative;
      min-height: 420px;
      padding-bottom: 60px;
      overflow: hidden;
    }

    .hero-content {
      position: relative;
      z-index: 2;
      max-width: 600px;
      padding-top: 20px;
    }

    /* Hero Title - Serif display, the ONE editorial element */
    .hero-title {
      font-family: var(--font-display);
      font-size: var(--h1);
      font-weight: 400;
      line-height: var(--lh-tight);
      letter-spacing: var(--track-tight);
      color: var(--ink);
      margin-bottom: 20px;
    }

    /* Hero text: unified system for subtitle, lede, and meta */
    .hero-subtitle,
    .hero-lede {
      font-family: var(--font-sans);
      font-size: 18px;
      font-weight: 400;
      font-style: normal;
      line-height: 1.5;
      color: var(--muted);
      max-width: 540px;
      margin: 0 0 14px 0;
    }

    .hero-meta {
      font-family: var(--font-sans);
      font-size: 18px;
      font-weight: 400;
      line-height: 1.5;
      color: #4f4f4f;
      letter-spacing: 0.02em;
      margin: 0;
    }

    /* ========== HERO ANIMATION ========== */
    .hero-visual {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
    }

    .hero-visual canvas {
      width: 100%;
      height: 100%;
    }

    /* Reduced motion: show static final state */
    @media (prefers-reduced-motion: reduce) {
      .hero-visual canvas {
        animation: none;
      }
    }

    /* ========== SECTION DIVIDER ========== */
    .section-divider {
      position: relative;
      height: 1px;
      background: var(--rule);
      margin: 60px 0;
    }

    .section-divider::after {
      content: '';
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 8px;
      height: 8px;
      background: var(--accent);
      border-radius: 50%;
    }

    .section-divider.dot-20::after { left: 20%; }
    .section-divider.dot-35::after { left: 35%; }
    .section-divider.dot-50::after { left: 50%; }
    .section-divider.dot-65::after { left: 65%; }
    .section-divider.dot-80::after { left: 80%; }

    /* ========== SECTIONS ========== */
    section {
      padding-bottom: 20px;
    }

    /* Section titles - Real headings, sentence case */
    .section-title {
      font-family: var(--font-sans);
      font-size: var(--h2);
      font-weight: 600;
      color: var(--ink);
      margin-bottom: 28px;
      line-height: var(--lh-head);
    }

    /* ========== EPIGRAPH ========== */
    .epigraph {
      border-left: 3px solid var(--accent);
      padding-left: 20px;
      margin: 0 0 40px;
      max-width: 580px;
    }

    .epigraph blockquote {
      font-family: var(--font-sans);
      font-size: 18px;
      font-weight: 400;
      font-style: normal;
      line-height: 1.5;
      color: var(--muted);
      margin: 0 0 10px;
    }

    .epigraph cite {
      display: block;
      font-family: var(--font-sans);
      font-size: 14px;
      font-style: normal;
      color: var(--quiet);
    }

    /* ========== PURPOSE CONTENT ========== */
    .purpose-content {
      max-width: 640px;
    }

    .purpose-content p {
      font-size: var(--body);
      margin-bottom: 24px;
      line-height: var(--lh-body);
      color: var(--muted);
    }

    /* ========== QUESTIONS ========== */
    .questions {
      max-width: 640px;
    }

    .questions-intro {
      font-size: var(--small);
      font-weight: 500;
      color: var(--muted);
      margin-bottom: 24px;
    }

    .questions-list {
      list-style: none;
    }

    .questions-list li {
      position: relative;
      padding-left: 20px;
      margin-bottom: 20px;
    }

    .questions-list li::before {
      content: '';
      position: absolute;
      left: 0;
      top: 8px;
      width: 6px;
      height: 6px;
      background: var(--accent);
      border-radius: 50%;
    }

    .questions-list .q {
      font-family: var(--font-sans);
      font-size: var(--body);
      font-weight: 500;
      color: var(--ink);
      line-height: 1.4;
      margin-bottom: 4px;
    }

    .questions-list .context {
      font-size: var(--small);
      color: var(--muted);
      line-height: 1.55;
    }

    /* ========== PROGRAM ========== */
    .program-grid {
      max-width: 640px;
    }

    .program-item {
      display: grid;
      grid-template-columns: 55px 1fr;
      gap: 20px;
      padding: 16px 0;
      border-bottom: 1px solid var(--rule);
    }

    .program-item:first-child {
      padding-top: 0;
    }

    .program-item:last-child {
      border-bottom: none;
    }

    .program-time {
      font-size: 14px;
      font-weight: 500;
      color: var(--quiet);
      font-variant-numeric: tabular-nums;
    }

    .program-title {
      font-size: var(--body);
      font-weight: 600;
      color: var(--ink);
      margin-bottom: 4px;
    }

    .program-desc {
      font-size: var(--small);
      color: var(--muted);
      line-height: 1.5;
    }

    /* ========== HOSTS ========== */
    .hosts-list {
      max-width: 640px;
      margin-bottom: 24px;
    }

    .hosts-list p {
      margin-bottom: 10px;
      font-size: var(--body);
    }

    .hosts-list a {
      color: var(--ink);
      text-decoration: none;
      font-weight: 600;
      transition: color 0.2s ease;
    }

    .hosts-list a:hover {
      color: var(--accent);
    }

    .hosts-list .role {
      color: var(--muted);
      font-weight: 400;
    }

    .hosts-meta {
      font-size: var(--small);
      color: var(--muted);
      margin-bottom: 18px;
      max-width: 640px;
    }

    .hosts-meta a {
      color: var(--ink);
      text-decoration: none;
      transition: color 0.2s ease;
    }

    .hosts-meta a:hover {
      color: var(--accent);
    }

    .organizers {
      font-size: var(--small);
      color: var(--muted);
    }

    .organizers a {
      color: var(--ink);
      text-decoration: none;
      transition: color 0.2s ease;
    }

    .organizers a:hover {
      color: var(--accent);
    }

    /* ========== CONTACT ========== */
    .contact-form {
      display: flex;
      flex-direction: column;
      gap: 24px;
      max-width: 400px;
      margin-bottom: 32px;
    }

    .form-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .form-group label {
      font-size: 14px;
      font-weight: 500;
      color: var(--quiet);
    }

    .form-group .optional {
      font-weight: 400;
    }

    .form-group input,
    .form-group textarea {
      font-family: var(--font-sans);
      font-size: 16px;
      padding: 12px 0;
      border: none;
      border-bottom: 1px solid var(--rule);
      background: transparent;
      color: var(--ink);
      transition: border-color 0.2s ease;
    }

    .form-group input:focus,
    .form-group textarea:focus {
      outline: none;
      border-bottom-color: var(--accent);
    }

    .form-group textarea {
      resize: vertical;
      min-height: 80px;
    }

    .submit-btn {
      align-self: flex-start;
      font-family: var(--font-sans);
      font-size: 14px;
      font-weight: 600;
      color: var(--ink);
      background: transparent;
      border: none;
      border-bottom: 1px solid var(--ink);
      padding: 0 0 4px 0;
      cursor: pointer;
      transition: color 0.2s ease, border-color 0.2s ease;
    }

    .submit-btn:hover {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }

    .contact-email {
      font-size: var(--small);
      color: var(--muted);
    }

    .contact-email a {
      color: var(--ink);
      text-decoration: none;
      transition: color 0.2s ease;
    }

    .contact-email a:hover {
      color: var(--accent);
    }

    /* ========== FOOTER ========== */
    footer {
      padding: 48px 0;
      border-top: 1px solid var(--rule);
      margin-top: 40px;
      text-align: left;
    }

    .footer-dot {
      width: 8px;
      height: 8px;
      background: var(--accent);
      border-radius: 50%;
      margin-bottom: 20px;
    }

    footer p {
      font-size: 13px;
      color: var(--quiet);
      margin-bottom: 6px;
    }

    footer .host-credit {
      font-size: 12px;
      color: var(--quiet);
    }

    /* ========== RESPONSIVE ========== */
    @media (max-width: 1024px) {
      :root {
        --left-margin: 5vw;
      }

      .hero {
        min-height: 380px;
      }
    }

    @media (max-width: 768px) {
      :root {
        --left-margin: 24px;
        --h1: 40px;
        --h2: 22px;
      }

      .page-wrap {
        padding-right: 24px;
      }

      .nav {
        flex-direction: column;
        gap: 16px;
        align-items: flex-start;
        margin-bottom: 40px;
      }

      .hero {
        min-height: auto;
        padding-bottom: 48px;
      }

      .hero-subtitle,
      .hero-lede,
      .hero-meta {
        font-size: 16px;
      }

      .hero-visual {
        opacity: 0.4;
      }

      .section-divider {
        margin: 48px 0;
      }

      .program-item {
        grid-template-columns: 50px 1fr;
        gap: 16px;
      }
    }

    @media (max-width: 480px) {
      :root {
        --h1: 34px;
        --h2: 20px;
      }

      .hero-subtitle,
      .hero-lede,
      .hero-meta {
        font-size: 15px;
      }

      .hero-visual {
        opacity: 0.3;
      }

      .program-item {
        grid-template-columns: 1fr;
        gap: 6px;
      }

      .program-time {
        font-size: 13px;
      }
    }
  </style>
</head>
<body>

  <div class="page-wrap">
    <div class="content-width">

      <!-- Navigation -->
      <nav class="nav">
        <a href="#" class="nav-brand">e184 × NeuroNYC</a>
        <div class="nav-links">
          <a href="#purpose">Purpose</a> · <a href="#program">Program</a> · <a href="#hosts">Hosts</a> · <a href="#contact">Contact</a>
        </div>
      </nav>

      <!-- Hero -->
      <section class="hero">
        <div class="hero-content">
          <h1 class="hero-title">Foundation Models<br>for the Brain</h1>
          <p class="hero-subtitle">Laying the groundwork for the next stage in neurotech and AI</p>
          <p class="hero-lede">An invite-only evening for researchers working on brain foundation models—across hardware, data, and real-world systems.</p>
          <p class="hero-meta">March 26, 2026 · 5–9 PM · Brown Rudnick · New York City</p>
        </div>

        <!-- Animated Background: Signal to Structure -->
        <div class="hero-visual" id="heroVisual">
          <canvas id="heroCanvas"></canvas>
        </div>
      </section>

      <!-- Divider -->
      <div class="section-divider dot-65"></div>

      <!-- Purpose Section -->
      <section id="purpose">
        <!-- Epigraph -->
        <div class="epigraph">
          <blockquote>
            "The most fruitful areas for the growth of the sciences were those which had been neglected as a no-man's land between the various established fields."
          </blockquote>
          <cite>— Norbert Wiener, 1948</cite>
        </div>

        <h2 class="section-title">Purpose of the event</h2>

        <div class="purpose-content">
          <p>Brain foundation models are advancing quickly, but the field is still working through basic constraints: what kinds of data are realistically available, what today's sensors can and can't capture, and what "progress" should mean in practice. Across the field, teams are pursuing different strategies—pushing existing sensors further, leaning on multimodal inputs, drawing on non-human data, building models around specific settings, or prioritizing near-term deployment.</p>

          <p>This invite-only evening brings together an interdisciplinary group of researchers and practitioners to share what's working, what isn't, and what "working" should even mean—given constraints in neural data, sensing, and deployment. The format: two panels, short provocations, and substantial time for discussion.</p>
        </div>

        <div class="questions">
          <p class="questions-intro">Questions we'll explore:</p>
          <ul class="questions-list">
            <li>
              <p class="q">Where is the bottleneck right now?</p>
              <p class="context">Is progress primarily constrained by sensors, data access, or modeling assumptions?</p>
            </li>
            <li>
              <p class="q">Which workarounds seem most promising—and why?</p>
              <p class="context">What strategies meaningfully move the needle under current constraints?</p>
            </li>
            <li>
              <p class="q">What counts as "enough" data (and of what kind)?</p>
              <p class="context">When does scale help, and when are there hard limits?</p>
            </li>
            <li>
              <p class="q">What does "working" mean in this space?</p>
              <p class="context">Which outcomes or applications feel real today, and which remain aspirational?</p>
            </li>
            <li>
              <p class="q">How do research and real-world systems inform one another?</p>
              <p class="context">What can we learn from early deployments, and what gets lost in translation?</p>
            </li>
          </ul>
        </div>
      </section>

      <!-- Divider -->
      <div class="section-divider dot-35"></div>

      <!-- Program Section -->
      <section id="program">
        <h2 class="section-title">Program</h2>

        <div class="program-grid">
          <div class="program-item">
            <span class="program-time">5:00</span>
            <div>
              <p class="program-title">Welcome and drinks</p>
            </div>
          </div>
          <div class="program-item">
            <span class="program-time">5:30</span>
            <div>
              <p class="program-title">Panel 1 — Building a high-quality brain foundation model</p>
              <p class="program-desc">Constraints, workaround strategies, and what the field still needs to figure out.</p>
            </div>
          </div>
          <div class="program-item">
            <span class="program-time">6:30</span>
            <div>
              <p class="program-title">Panel 2 — From research to deployment</p>
              <p class="program-desc">Validation, integration, and near-term value across clinical, invasive, and consumer paths.</p>
            </div>
          </div>
          <div class="program-item">
            <span class="program-time">7:30</span>
            <div>
              <p class="program-title">Keynote</p>
            </div>
          </div>
          <div class="program-item">
            <span class="program-time">8:00</span>
            <div>
              <p class="program-title">Reception and informal discussion</p>
            </div>
          </div>
        </div>
      </section>

      <!-- Divider -->
      <div class="section-divider dot-50"></div>

      <!-- Hosts Section -->
      <section id="hosts">
        <h2 class="section-title">Hosts & Venue</h2>

        <div class="hosts-list">
          <p><a href="https://e184.org" target="_blank" rel="noopener">e184</a> <span class="role">— Co-host</span></p>
          <p><a href="https://neuro-nyc.org" target="_blank" rel="noopener">NeuroNYC</a> <span class="role">— Co-host</span></p>
          <p><a href="https://www.brownrudnick.com" target="_blank" rel="noopener">Brown Rudnick</a> <span class="role">— Venue</span></p>
        </div>

        <p class="organizers">
          Organized by
          <a href="https://www.linkedin.com/in/margot-hanley-phd-5183aa20/" target="_blank" rel="noopener">Margot Hanley</a> (NeuroNYC)
          and
          <a href="https://www.linkedin.com/in/peter-zhegin-526a993/" target="_blank" rel="noopener">Peter Zhegin</a> (e184)
        </p>
      </section>

      <!-- Divider -->
      <div class="section-divider dot-20"></div>

      <!-- Contact Section -->
      <section id="contact">
        <h2 class="section-title">Request an invite</h2>

        <form class="contact-form" action="https://formspree.io/f/placeholder" method="POST">
          <div class="form-group">
            <label for="name">Name</label>
            <input type="text" id="name" name="name" required>
          </div>
          <div class="form-group">
            <label for="email">Email</label>
            <input type="email" id="email" name="email" required>
          </div>
          <div class="form-group">
            <label for="affiliation">Affiliation</label>
            <input type="text" id="affiliation" name="affiliation" required>
          </div>
          <div class="form-group">
            <label for="note">Note <span class="optional">(optional)</span></label>
            <textarea id="note" name="note" placeholder="Brief context on your work or interest"></textarea>
          </div>
          <button type="submit" class="submit-btn">Submit request →</button>
        </form>

        <p class="contact-email">For other questions, reach out to <a href="mailto:margothanley@gmail.com">margothanley@gmail.com</a></p>
      </section>

      <!-- Footer -->
      <footer>
        <div class="footer-dot"></div>
        <p>Foundation Models for the Brain · March 26, 2026 · New York City</p>
        <p class="host-credit">Hosted by e184 × NeuroNYC</p>
      </footer>

    </div>
  </div>

  <!-- Hero Animation: Signal → Structure -->
  <script>
    (function() {
      'use strict';

      // ============ CONFIGURATION ============
      const CONFIG = {
        // Dot settings
        dotCount: 80,
        dotMinRadius: 2,
        dotMaxRadius: 4.5,

        // Colors (semantic: different "data types" as subtle blue variations)
        colors: {
          human: 'rgba(121, 191, 208, 0.85)',      // #79BFD0 - primary
          animal: 'rgba(142, 200, 215, 0.75)',     // slightly lighter
          synthetic: 'rgba(168, 213, 226, 0.65)', // #A8D5E2 - lightest
          line: 'rgba(121, 191, 208, 0.25)'
        },

        // Network settings
        maxEdgesPerNode: 3,
        edgeDistance: 80,
        lineWidth: 1,

        // Timing (in seconds)
        timing: {
          scatter: 2,      // 0-2s: scattered noise
          swirl: 4,        // 2-6s: swirl + clustering
          structure: 4,    // 6-10s: form network
          rest: 2,         // 10-12s: stable
          dissolve: 3,     // 12-15s: dissolve back
          total: 15        // full loop
        },

        // Physics
        dampening: 0.95,
        clusterAttraction: 0.0008,
        noiseStrength: 0.3
      };

      // ============ SETUP ============
      const canvas = document.getElementById('heroCanvas');
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      const container = document.getElementById('heroVisual');

      // Check for reduced motion preference
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      let width, height, dpr;
      let dots = [];
      let edges = [];
      let animationTime = 0;
      let lastTimestamp = 0;

      // Cluster target positions (will be calculated based on canvas size)
      let clusterCenters = [];

      function resize() {
        dpr = window.devicePixelRatio || 1;
        width = container.offsetWidth;
        height = container.offsetHeight;

        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';

        ctx.scale(dpr, dpr);

        // Recalculate cluster centers (positioned on right side)
        const rightOffset = width * 0.55;
        const verticalSpread = height * 0.6;
        const verticalOffset = height * 0.2;

        clusterCenters = [
          { x: rightOffset + width * 0.15, y: verticalOffset + verticalSpread * 0.2 },
          { x: rightOffset + width * 0.25, y: verticalOffset + verticalSpread * 0.5 },
          { x: rightOffset + width * 0.15, y: verticalOffset + verticalSpread * 0.8 },
          { x: rightOffset + width * 0.30, y: verticalOffset + verticalSpread * 0.35 },
          { x: rightOffset + width * 0.30, y: verticalOffset + verticalSpread * 0.65 }
        ];
      }

      function initDots() {
        dots = [];
        const colorTypes = ['human', 'animal', 'synthetic'];

        for (let i = 0; i < CONFIG.dotCount; i++) {
          // Assign to a cluster
          const clusterIndex = Math.floor(Math.random() * clusterCenters.length);

          // Random initial position (scattered, biased toward left/center)
          const scatterX = Math.random() * width * 0.5 + width * 0.05;
          const scatterY = Math.random() * height * 0.8 + height * 0.1;

          // Target position near cluster center with some spread
          const cluster = clusterCenters[clusterIndex];
          const targetX = cluster.x + (Math.random() - 0.5) * 60;
          const targetY = cluster.y + (Math.random() - 0.5) * 50;

          // Color based on "data type" (visual only, no legend needed)
          const colorType = colorTypes[Math.floor(Math.random() * colorTypes.length)];

          dots.push({
            // Current position
            x: scatterX,
            y: scatterY,

            // Velocity
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,

            // Positions
            scatterX: scatterX,
            scatterY: scatterY,
            targetX: targetX,
            targetY: targetY,

            // Properties
            radius: CONFIG.dotMinRadius + Math.random() * (CONFIG.dotMaxRadius - CONFIG.dotMinRadius),
            color: CONFIG.colors[colorType],
            colorType: colorType,
            cluster: clusterIndex,

            // Animation
            phase: Math.random() * Math.PI * 2,
            speed: 0.5 + Math.random() * 0.5,
            swirlRadius: 20 + Math.random() * 40,
            swirlSpeed: 0.3 + Math.random() * 0.4
          });
        }
      }

      function calculateEdges() {
        edges = [];

        // For each dot, find nearest neighbors and create edges
        for (let i = 0; i < dots.length; i++) {
          const dot = dots[i];
          const distances = [];

          for (let j = 0; j < dots.length; j++) {
            if (i === j) continue;
            const other = dots[j];
            const dx = dot.targetX - other.targetX;
            const dy = dot.targetY - other.targetY;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < CONFIG.edgeDistance) {
              distances.push({ index: j, dist: dist });
            }
          }

          // Sort by distance and take closest
          distances.sort((a, b) => a.dist - b.dist);
          const edgeCount = Math.min(CONFIG.maxEdgesPerNode, distances.length);

          for (let k = 0; k < edgeCount; k++) {
            const j = distances[k].index;
            // Avoid duplicate edges
            if (i < j) {
              edges.push({ from: i, to: j, dist: distances[k].dist });
            }
          }
        }
      }

      // Easing functions
      function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }

      function easeOutQuad(t) {
        return 1 - (1 - t) * (1 - t);
      }

      function getPhase(time) {
        const t = CONFIG.timing;
        const loopTime = time % t.total;

        if (loopTime < t.scatter) {
          return { phase: 'scatter', progress: loopTime / t.scatter };
        } else if (loopTime < t.scatter + t.swirl) {
          return { phase: 'swirl', progress: (loopTime - t.scatter) / t.swirl };
        } else if (loopTime < t.scatter + t.swirl + t.structure) {
          return { phase: 'structure', progress: (loopTime - t.scatter - t.swirl) / t.structure };
        } else if (loopTime < t.scatter + t.swirl + t.structure + t.rest) {
          return { phase: 'rest', progress: (loopTime - t.scatter - t.swirl - t.structure) / t.rest };
        } else {
          return { phase: 'dissolve', progress: (loopTime - t.scatter - t.swirl - t.structure - t.rest) / t.dissolve };
        }
      }

      function updateDots(deltaTime, phaseInfo) {
        const { phase, progress } = phaseInfo;

        dots.forEach((dot, i) => {
          let targetX, targetY;

          switch (phase) {
            case 'scatter':
              // Gentle drift with noise
              targetX = dot.scatterX + Math.sin(animationTime * dot.speed + dot.phase) * 15;
              targetY = dot.scatterY + Math.cos(animationTime * dot.speed * 0.7 + dot.phase) * 15;
              break;

            case 'swirl':
              // Swirl toward clusters
              const swirlT = easeInOutCubic(progress);
              const swirlAngle = animationTime * dot.swirlSpeed + dot.phase;
              const swirlDist = dot.swirlRadius * (1 - swirlT * 0.7);

              const midX = dot.scatterX + (dot.targetX - dot.scatterX) * swirlT;
              const midY = dot.scatterY + (dot.targetY - dot.scatterY) * swirlT;

              targetX = midX + Math.cos(swirlAngle) * swirlDist;
              targetY = midY + Math.sin(swirlAngle) * swirlDist;
              break;

            case 'structure':
              // Settle into final positions
              const structT = easeOutQuad(progress);
              const idleX = Math.sin(animationTime * 0.3 + dot.phase) * 2;
              const idleY = Math.cos(animationTime * 0.25 + dot.phase) * 2;

              targetX = dot.targetX + idleX * (1 - structT * 0.5);
              targetY = dot.targetY + idleY * (1 - structT * 0.5);
              break;

            case 'rest':
              // Very subtle idle movement
              targetX = dot.targetX + Math.sin(animationTime * 0.2 + dot.phase) * 1.5;
              targetY = dot.targetY + Math.cos(animationTime * 0.15 + dot.phase) * 1.5;
              break;

            case 'dissolve':
              // Drift back toward scattered positions
              const dissolveT = easeInOutCubic(progress);
              targetX = dot.targetX + (dot.scatterX - dot.targetX) * dissolveT;
              targetY = dot.targetY + (dot.scatterY - dot.targetY) * dissolveT;
              targetX += Math.sin(animationTime * dot.speed + dot.phase) * 10 * dissolveT;
              targetY += Math.cos(animationTime * dot.speed * 0.7 + dot.phase) * 10 * dissolveT;
              break;
          }

          // Smooth movement toward target
          const dx = targetX - dot.x;
          const dy = targetY - dot.y;
          dot.vx += dx * 0.08;
          dot.vy += dy * 0.08;
          dot.vx *= CONFIG.dampening;
          dot.vy *= CONFIG.dampening;
          dot.x += dot.vx;
          dot.y += dot.vy;
        });
      }

      function draw(phaseInfo) {
        const { phase, progress } = phaseInfo;

        // Clear canvas
        ctx.clearRect(0, 0, width, height);

        // Calculate edge opacity based on phase
        let edgeOpacity = 0;
        if (phase === 'swirl' && progress > 0.5) {
          edgeOpacity = (progress - 0.5) * 2 * 0.3;
        } else if (phase === 'structure') {
          edgeOpacity = 0.3 + progress * 0.1;
        } else if (phase === 'rest') {
          edgeOpacity = 0.4;
        } else if (phase === 'dissolve') {
          edgeOpacity = 0.4 * (1 - progress);
        }

        // Draw edges
        if (edgeOpacity > 0) {
          ctx.strokeStyle = `rgba(121, 191, 208, ${edgeOpacity})`;
          ctx.lineWidth = CONFIG.lineWidth;
          ctx.beginPath();

          edges.forEach(edge => {
            const from = dots[edge.from];
            const to = dots[edge.to];
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
          });

          ctx.stroke();
        }

        // Draw dots
        dots.forEach(dot => {
          ctx.beginPath();
          ctx.arc(dot.x, dot.y, dot.radius, 0, Math.PI * 2);
          ctx.fillStyle = dot.color;
          ctx.fill();
        });
      }

      function animate(timestamp) {
        if (!lastTimestamp) lastTimestamp = timestamp;
        const deltaTime = (timestamp - lastTimestamp) / 1000;
        lastTimestamp = timestamp;

        animationTime += deltaTime;

        const phaseInfo = getPhase(animationTime);
        updateDots(deltaTime, phaseInfo);
        draw(phaseInfo);

        requestAnimationFrame(animate);
      }

      function drawStaticFinalState() {
        // For reduced motion: show the final structured network
        ctx.clearRect(0, 0, width, height);

        // Position dots at their targets
        dots.forEach(dot => {
          dot.x = dot.targetX;
          dot.y = dot.targetY;
        });

        // Draw edges
        ctx.strokeStyle = CONFIG.colors.line;
        ctx.lineWidth = CONFIG.lineWidth;
        ctx.beginPath();

        edges.forEach(edge => {
          const from = dots[edge.from];
          const to = dots[edge.to];
          ctx.moveTo(from.x, from.y);
          ctx.lineTo(to.x, to.y);
        });

        ctx.stroke();

        // Draw dots
        dots.forEach(dot => {
          ctx.beginPath();
          ctx.arc(dot.x, dot.y, dot.radius, 0, Math.PI * 2);
          ctx.fillStyle = dot.color;
          ctx.fill();
        });
      }

      // Initialize
      function init() {
        resize();
        initDots();
        calculateEdges();

        if (prefersReducedMotion) {
          drawStaticFinalState();
        } else {
          requestAnimationFrame(animate);
        }
      }

      // Handle resize
      let resizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          resize();
          initDots();
          calculateEdges();
          if (prefersReducedMotion) {
            drawStaticFinalState();
          }
        }, 150);
      });

      // Start after DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>

</body>
</html>
